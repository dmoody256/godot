#!/usr/bin/env python

Import("env")

env.editor_sources = []

import os
import os.path
import sys
import glob
import pathlib
from editor import editor_builders

import SCons

editor_env = env.Clone()

if env["tools"]:
    # Register exporters
    reg_exporters_inc = '#include "register_exporters.h"\n'
    reg_exporters = "void register_exporters() {\n"

    editor_env.Append(CPPPATH=[editor_env.Dir(".")])
    for e in env.platform_exporters:
        # Glob all .cpp files in export folder and remove the

        platform_dir = env.Dir("#platform/" + e)
        files = glob.glob(os.path.join(platform_dir.abspath, "export", "*.cpp"))
        # adjusting the path to match our variant dir
        files = ["/".join(pathlib.Path(file).parts[-4:]) for file in files]
        editor_env.VariantDir("platform/" + e, platform_dir, duplicate=0)

        editor_env.add_source_files(env.editor_sources, files)

        reg_exporters += "\tregister_" + e + "_exporter();\n"
        reg_exporters_inc += '#include "platform/' + e + '/export/export.h"\n'
    reg_exporters += "}\n"

    register_exporters = editor_env.Textfile(
        "register_exporters.gen.cpp",
        [
            reg_exporters_inc,
            reg_exporters,
        ],
        LINESEPARATOR="",
    )
    editor_env.Append(CPPPATH=[editor_env.Dir(".").srcnode(), editor_env.Dir(".")])

    # Core API documentation.
    docs = []
    docs += editor_env.Glob("#doc/classes/*.xml")

    # Module API documentation.
    module_dirs = []
    for d in env.doc_class_path.values():
        if d not in module_dirs:
            module_dirs.append(d)

    for d in module_dirs:
        if not os.path.isabs(d):
            docs += editor_env.Glob("#" + d + "/*.xml")  # Built-in.
        else:
            docs += editor_env.Glob(d + "/*.xml")  # Custom.

    doc_data_class = editor_env.Textfile(
        "doc_data_class_path.gen.h",
        [
            "static const int _doc_data_class_path_count = " + str(len(env.doc_class_path)) + ";"
            "struct _DocDataClassPath { const char* name; const char* path; };",
            "static const _DocDataClassPath _doc_data_class_paths[" + str(len(env.doc_class_path) + 1) + "] = {",
        ]
        + ['\t{"' + c + '", "' + env.doc_class_path[c] + '"},' for c in sorted(env.doc_class_path)]
        + [
            "\t{nullptr, nullptr}",
            "};",
        ],
    )

    editor_env.Command(
        "doc_data_compressed.gen.h",
        sorted(docs),
        Action(editor_builders.make_doc_header, "Generating documentation header."),
    )

    # Editor interface and class reference translations incur a significant size
    # cost for the editor binary (see godot-proposals#3421).
    # To limit it, we only include translations with a high enough completion
    # ratio (30% for the editor UI, 10% for the class reference).
    # Generated with `make include-list` for each resource.
    
    # Editor translations
    to_include = (
        "ar,bg,bn,ca,cs,de,el,eo,es_AR,es,fi,fr,gl,he,hu,id,it,ja,ko,lv,ms,nb,nl,pl,pt_BR,pt,ro,ru,sk,sv,th,tr,uk,vi,zh_CN,zh_TW"
    ).split(",")
    tlist = [env.Dir("#editor/translations").abspath + "/" + f + ".po" for f in to_include]
    editor_env.Command(
        "editor_translations.gen.h",
        tlist,
        Action(editor_builders.make_editor_translations_header, "Generating editor translations header."),
    )

    # Documentation translations
    to_include = "de,es,fr,ja,zh_CN".split(",")
    tlist = [env.Dir("#doc/translations").abspath + "/" + f + ".po" for f in to_include]
    editor_env.Command(
        "doc_translations.gen.h",
        tlist,
        Action(editor_builders.make_doc_translations_header, "Generating translations header."),
    )

    # Fonts
    def font_gen_subst(env, target, source, for_signature):
        if for_signature:
            return env.File(env["FONT_HEADER_SCRIPT"]).get_csig()
        return env["FONT_HEADER_SCRIPT"]


    editor_env["FONT_HEADER_SCRIPT"] = editor_env.File("font_header_generator.py")
    editor_env["FONT_HEADER_SCRIPT_GEN"] = font_gen_subst
    editor_env["BUILDERS"]["FontHeader"] = SCons.Builder.Builder(
        action=Action(f"{sys.executable} $FONT_HEADER_SCRIPT_GEN $TARGETS $SOURCES", "Generating builtin fonts header.")
    )

    flist = editor_env.Glob("#thirdparty/fonts/*.ttf") + editor_env.Glob("#thirdparty/fonts/*.otf")
    editor_env.FontHeader("builtin_fonts.gen.h", sorted(flist))

    env.add_source_files(env.editor_sources, "*.cpp")
    env.add_source_files(env.editor_sources, "register_exporters.gen.cpp")

    SConscript("debugger/SCsub", duplicate=0)
    SConscript("fileserver/SCsub", duplicate=0)
    SConscript("icons/SCsub", duplicate=0, exports={"editor_env": editor_env})
    SConscript("import/SCsub", duplicate=0)
    SConscript("plugins/SCsub", duplicate=0)

    lib = editor_env.add_library("editor", env.editor_sources)
    env.Prepend(LIBS=[lib])
